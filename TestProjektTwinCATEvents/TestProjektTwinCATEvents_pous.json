[
  {
    "name": "FB_Automatikbetrieb_F1",
    "pou_type": "FunctionBlock",
    "implementation_lang": "ST",
    "declaration": "FUNCTION_BLOCK PUBLIC FB_Automatikbetrieb_F1\nVAR_INPUT\n    Automatikbetrieb_Starten : BOOL;\n\tAutoRestartEnable   : BOOL;      // Schalter für Autorestart\n    // <<< NEU: parametrierbarer, periodischer Störgenerator >>>\n    PeriodicFaultEnable : BOOL := TRUE;       // Ein/Aus\n    PeriodicFaultPeriod : TIME := T#60s;      // z. B. jede Minute\n    FaultPulse          : TIME := T#100ms;    // wie lange „Störung“ getriggert wird\nEND_VAR\nVAR RETAIN\n    lastSkillIsOne : BOOL := FALSE; // FALSE => erster Start wird TestSkill3 -> wir setzen gleich initial um\nEND_VAR\nVAR_OUTPUT\n    Automatikbetrieb_Fertig : BOOL;\n    Stoerung_erkannt        : BOOL;\nEND_VAR\nVAR\n    Schritt1 : BOOL;\n    Schritt2 : BOOL;\n\tZwischen : STRING;\n    tSchritt1 : TON;\n    tSchritt2 : TON;\n    rStart   : R_TRIG;\n    rtStoer   : R_TRIG;\n\trStep1 : R_TRIG;\n\n    // <<< NEU >>>\n    tPer   : TON;      // Periodentimer\n    rPer   : R_TRIG;   // Flanke bei Periodenende\n    pPer   : TP;       // kurzer Puls für die Störung\n    perEn  : BOOL;     // Enable nur wenn die Automatik läuft\n    dbg_Stoerung_Manuell : BOOL; // hattest du schon\n\ttpRestart: INT;\n\tRestartPulseLength: INT;\nEND_VAR",
    "implementation": "//GVL.Start := TRUE;\nIF GVL.Start THEN\n\tAutoRestartEnable := TRUE;\nEND_IF\n// === Flanken bilden ===\nrStart(CLK := Automatikbetrieb_Starten);\nrStep1(CLK := Schritt1);\n\n// === Startsequenz auf positive Flanke, nur wenn nicht bereits aktiv ===\nIF (AutoRestartEnable AND NOT (Schritt1 OR Schritt2)) OR (Stoerung_erkannt AND GVL.Weiter) THEN\n    // Reset aller Zustände\n    Automatikbetrieb_Fertig := FALSE;\n    Stoerung_erkannt        := FALSE;\n\tGVL.Weiter := FALSE;\n    // Start in Schritt 1\n    Schritt1 := TRUE;\n\tOPCUA.lastExecutedProcess := 'ExTechnProcess1';\n    Schritt2 := FALSE;\nEND_IF\n\n// === Timer an die Schritte koppeln ===\ntSchritt1(IN := Schritt1, PT := T#55S);\ntSchritt2(IN := Schritt2, PT := T#55S);\n\nIF rStep1.Q THEN\n    lastSkillIsOne := NOT lastSkillIsOne;\n    IF lastSkillIsOne THEN\n        OPCUA.lastExecutedSkill := 'TestSkill1';\n    ELSE\n        OPCUA.lastExecutedSkill := 'TestSkill1';\n    END_IF\nEND_IF\n\nIF rStart.Q AND NOT (Schritt1 OR Schritt2) THEN\n    Automatikbetrieb_Fertig := FALSE;\n    Stoerung_erkannt := FALSE;\n    GVL.Weiter := FALSE;\n    Schritt1 := TRUE;\n    Schritt2 := FALSE;\n    OPCUA.lastExecutedProcess := 'ExTechnProcess1';\nEND_IF\n\n// === Übergänge (sofern keine Störung aktiv ist) ===\nIF NOT Stoerung_erkannt THEN\n    // Schritt 1 -> 2 nach 30 s\n    IF Schritt1 AND tSchritt1.Q THEN\n        Schritt1 := FALSE;\n        Schritt2 := TRUE;\n\t\tOPCUA.lastExecutedSkill := 'TestSkill1';\n    END_IF\n\n    // Schritt 2 -> Fertig nach 10 s\n    IF Schritt2 AND tSchritt2.Q THEN\n        Schritt2 := FALSE;\n        Automatikbetrieb_Fertig := TRUE;\n        // Hier KEIN automatischer Neustart; neuer Start benötigt erneute Startflanke\n    END_IF\nEND_IF\n\n// === Störungen behandeln (manuell) ===\nIF rtStoer.Q THEN\n    Stoerung_erkannt := TRUE;\nEND_IF\n\n/// frei laufender Periodentimer (unabhängig von Schritt1/2) für Störung\ntPer(IN := NOT tPer.Q, PT := PeriodicFaultPeriod);  // z.B. T#60s\n\n// Flanke bei Periodenende + definierter Puls\nrPer(CLK := tPer.Q);\npPer(IN := rPer.Q, PT := FaultPulse);                // z.B. T#100ms\n\n// nur auslösen, wenn die Automatik gerade läuft\nIF (Schritt1 OR Schritt2) AND pPer.Q THEN\n    Stoerung_erkannt := TRUE;\n\tGVL.Fehler := TRUE;\nEND_IF",
    "file": "C:\\Users\\Alexander Verkhov\\OneDrive\\Dokumente\\MPA\\TestProjektTwinCATEvents\\TestProjektTwinCATEvents\\Proj1\\POUs\\FB_Automatikbetrieb_F1.TcPOU"
  },
  {
    "name": "FB_Betriebsarten",
    "pou_type": "FunctionBlock",
    "implementation_lang": "NWL",
    "declaration": "FUNCTION_BLOCK FB_Betriebsarten\nVAR_INPUT\n\tStart, NotStop, Weiter, Fehler, Start_Init : BOOL;\n    Auto_Fertig   : BOOL; // kommt von fbAuto.Automatikbetrieb_Fertig\n    Auto_Stoerung : BOOL; // kommt von fbAuto.Stoerung_erkannt\n\tA2_Requested: BOOL;\n\tAlt_abort: BOOL;\n\tAlt_found: BOOL;\n\tD3_Requested: BOOL;\n\tInit_reached: BOOL;\n\tCycle_ended: BOOL;\n\t//Reset\t\t\t: BOOL;\n\t//Schalter\t\t: BOOL;\n\t//Schrittkette_GS : BOOL;\nEND_VAR\nVAR_OUTPUT\n\tA1 : BOOL; //Initialzustand\n\tA2 : BOOL; //Stillstand angefordert am Ende des Zyklus\n//\tA3 : BOOL; //Stillstand angefordert in einem bestimmten Zustand\n//\tA4 : BOOL; //Erhaltener Stillstand\n\tA5 : BOOL; //Vorbereitung zur Wiederaufnahme nach Störung\n\tA6 : BOOL; //Fahrt in den Initialzustand\n\tF1 : BOOL; //Normalbetrieb\n//\tF2 : BOOL; //Anfahren\n//\tF3 : BOOL; //Abfahren\n\tF4 : BOOL; //Handbetrieb\n//\tF5 : BOOL; //Schrittbetrieb\n//\tF6 : BOOL; //Testbetrieb\n\tD1 : BOOL; //Not-Aus\n\tD2 : BOOL; //DIagnose und Störbehandlung\n\tD3 : BOOL; //Produktion trotz Störung\nEND_VAR\nVAR\n\tbFirstScan : BOOL := TRUE;\t\n\n\tRS_InitialState: RS;\t\n\tRS_InitialDrive: RS;\n\tRS_ManualOperationMode: RS;\n\tRS_AutomaticOperationMode: RS;\n\tRS_CycleEnded: RS;\n\n\tR_TRIG_Manual: R_TRIG;\n\tR_TRIG_Automatic: R_TRIG;\n\tR_TRIG_InitialDrive: R_TRIG;\n\tR_TRIG_CycleEnded: R_TRIG;\n\tR_TRIG_Init: R_TRIG;\n\tRS_D2: RS;\n\tRS_F1: RS;\n\tRS_D1: RS;\n\tRS_A5: RS;\n\tRS_A1: RS;\n\n\tRS_D3: RS;\n\n\tRS_A2: RS;\n\tRS_A6: RS;\nEND_VAR",
    "implementation": "",
    "file": "C:\\Users\\Alexander Verkhov\\OneDrive\\Dokumente\\MPA\\TestProjektTwinCATEvents\\TestProjektTwinCATEvents\\Proj1\\POUs\\FB_Betriebsarten.TcPOU"
  },
  {
    "name": "FB_Diagnose_D2",
    "pou_type": "FunctionBlock",
    "implementation_lang": "ST",
    "declaration": "FUNCTION_BLOCK PUBLIC FB_Diagnose_D2\nVAR_INPUT\n    Diagnose_gefordert         : BOOL;  // z. B. D2 aus FB_Betriebsarten\nEND_VAR\nVAR_OUTPUT\n    Diagnose_beendet           : BOOL;  // geht zurück an FB_Betriebsarten\n\tAlt_gefunden\t\t\t   : BOOL := FALSE;\nEND_VAR\nVAR\n    // Steuerung/Handshake intern\n    Busy       : BOOL;\n\n    // Flanken + Puls\n    rtReq      : R_TRIG;    // steigende Flanke auf Diagnose_gefordert\n\trtD3 : R_TRIG;\n    tpPulse    : TP;        // kurzer Puls für OPCUA.TriggerD2 (z. B. 100 ms)\n    rtFinished : R_TRIG;    // steigende Flanke auf OPCUA.DiagnoseFinished\n\t rtAck : R_TRIG;\nEND_VAR",
    "implementation": "// 1) Startflanke erkennen\nrtReq(CLK := Diagnose_gefordert);\n\n// 2) Einmalig triggern (nur wenn noch nicht \"Busy\"):\nIF rtReq.Q AND NOT Busy THEN\n    Busy := TRUE;\n\tAlt_gefunden := FALSE;\n\tOPCUA.TriggerD2 := TRUE; \n\tOPCUA.bool1 := TRUE;\nEND_IF\n\n  // {attribute 'OPC.UA.DA' := '1'} in der GVL setzen\n\n// 3) Fertigmeldung vom OPC-UA-Client\n//rtFinished(CLK := OPCUA.DiagnoseFinished);\nrtAck(CLK := OPCUA.DiagnoseFinished);\nrtD3(CLK := OPCUA.Alt_found);\nIF rtAck.Q OR rtD3.Q THEN\n    Diagnose_beendet := TRUE;\n    GVL.Weiter := TRUE;\n    Busy := FALSE;\n    OPCUA.TriggerD2 := FALSE;\n\tOPCUA.bool2 := FALSE;\n    GVL.Fehler := FALSE;\n    Diagnose_gefordert := FALSE;\n\tGVL.DiagnoseRequested := FALSE;\nEND_IF\nIF rtD3.Q THEN\n\tAlt_gefunden := TRUE;\nEND_IF",
    "file": "C:\\Users\\Alexander Verkhov\\OneDrive\\Dokumente\\MPA\\TestProjektTwinCATEvents\\TestProjektTwinCATEvents\\Proj1\\POUs\\FB_Diagnose_D2.TcPOU"
  },
  {
    "name": "FB_InitFahrt_A6_A2",
    "pou_type": "FunctionBlock",
    "implementation_lang": "ST",
    "declaration": "FUNCTION_BLOCK FB_InitFahrt_A6_A2\nVAR_INPUT\n\tA6 : BOOL := FALSE;\n\tA2: BOOL := FALSE;\nEND_VAR\nVAR_OUTPUT\n\tInit_erreicht : BOOL := FALSE;\nEND_VAR\nVAR\n\ttInit : TON;\nEND_VAR",
    "implementation": "IF A6 THEN\n\ttInit(IN := A6, PT := T#3S);\nELSIF A2 THEN\n\ttInit(IN := A2, PT := T#5S);\nEND_IF\n\nIF tInit.Q THEN\n\tInit_erreicht := TRUE;\nELSE\n\tInit_erreicht := FALSE;\nEND_IF",
    "file": "C:\\Users\\Alexander Verkhov\\OneDrive\\Dokumente\\MPA\\TestProjektTwinCATEvents\\TestProjektTwinCATEvents\\Proj1\\POUs\\FB_InitFahrt_A6_A2.TcPOU"
  },
  {
    "name": "FB_ProduktionMitStoerung_D3",
    "pou_type": "FunctionBlock",
    "implementation_lang": "ST",
    "declaration": "FUNCTION_BLOCK FB_ProduktionMitStoerung_D3\nVAR_INPUT\n    ProduktionMitStoerung_Starten : BOOL;\nEND_VAR\nVAR RETAIN\n    lastSkillIsOne : BOOL := FALSE; // FALSE => erster Start wird TestSkill3 -> wir setzen gleich initial um\nEND_VAR\nVAR_OUTPUT\n    Fertig : BOOL;\n    Stoerung_erkannt        : BOOL;\nEND_VAR\nVAR\n    Schritt3 : BOOL;\n    Schritt4 : BOOL;\n\tZwischen : STRING;\n    tSchritt3 : TON;\n    tSchritt4 : TON;\n    rStart   : R_TRIG;\n    rtStoer   : R_TRIG;\n\trStep1 : R_TRIG;\n\tz : INT := 0;\n\n    // <<< NEU >>>\n    tPer   : TON;      // Periodentimer\n    rPer   : R_TRIG;   // Flanke bei Periodenende\n    pPer   : TP;       // kurzer Puls für die Störung\n    perEn  : BOOL;     // Enable nur wenn die Automatik läuft\n    dbg_Stoerung_Manuell : BOOL; // hattest du schon\n\ttpRestart: INT;\n\tRestartPulseLength: INT;\nEND_VAR",
    "implementation": "rStart(CLK := ProduktionMitStoerung_Starten);\nIF rStart.Q THEN\n\tz := 0;\nEND_IF\n\nIF ProduktionMitStoerung_Starten AND NOT (Schritt3 OR Schritt4) AND NOT Stoerung_erkannt THEN\n\tFertig := FALSE;\n\tSchritt3 := TRUE;\n\tOPCUA.lastExecutedSkill := 'TestSkill3';\n\tOPCUA.lastExecutedProcess := 'D3Process';\n\tSchritt4 := FALSE;\nEND_IF\n\ntSchritt3(IN := Schritt3, PT:=T#10S);\ntSchritt4(IN := Schritt4, PT:=T#10S);\n\nIF tSchritt3.Q THEN\n\tSchritt3 := FALSE;\n\tz := z+1;\n\tIF z > 2 THEN\n\t\tStoerung_erkannt := TRUE;\n\t\tOPCUA.Alt_abort := TRUE;\n\tEND_IF\n\tIF NOT Stoerung_erkannt THEN\n\t\tSchritt4 := TRUE;\n\t\tOPCUA.lastExecutedSkill := 'TestSkill4';\n\tEND_IF\nEND_IF\n\nIF tSchritt4.Q THEN\n\tSchritt4 := FALSE;\n\tSchritt3 := TRUE;\n\tOPCUA.lastExecutedSkill := 'TestSkill3';\nEND_IF",
    "file": "C:\\Users\\Alexander Verkhov\\OneDrive\\Dokumente\\MPA\\TestProjektTwinCATEvents\\TestProjektTwinCATEvents\\Proj1\\POUs\\FB_ProduktionMitStoerung_D3.TcPOU"
  },
  {
    "name": "MAIN",
    "pou_type": "Program",
    "implementation_lang": "ST",
    "declaration": "PROGRAM MAIN\nVAR\n\t{attribute 'OPC.UA.DA' := '1'}       // falls Server im Filter-/Symbolmodus\n    fbJob : FB_Methode1Job;              // FB mit {attribute 'OPC.UA.DA.JobMethod' := 'M_Methode1'}\n    fbBA   : FB_Betriebsarten;\n    fbAuto : FB_Automatikbetrieb_F1;\n    fbDiag : FB_Diagnose_D2;\n\tfbNot : FB_Notaus_D1;\n\tfbInit : FB_InitFahrt_A6_A2;\n\tfbProStoer : FB_ProduktionMitStoerung_D3;\n\t\n\tInit_start : BOOL := TRUE;\n\t\n\n    edgeF1    : R_TRIG;  // F1 -> Start Automatik\n    edgeDone  : R_TRIG;  // Diagnose_beendet -> Restart/Weiter\n\talt_abort : BOOL := FALSE;\n\talt_found : BOOL := FALSE;\n    Start_eff  : BOOL := FALSE;\n    Weiter_eff : BOOL := FALSE;\n\tA2_angefordert : BOOL := FALSE;\n\tD3_angefordert : BOOL := FALSE;\n\tInit_erreicht : BOOL := FALSE;\n\tZyklus_beendet : BOOL := FALSE;\n\t\nEND_VAR",
    "implementation": "// Diagnose fertig -> Impuls\nedgeDone(CLK := fbDiag.Diagnose_beendet);\n\n// manuell ODER automatisch (Restart nach Diagnose)\nStart_eff  := GVL.Start  OR edgeDone.Q;\nWeiter_eff := GVL.Weiter OR edgeDone.Q;\n\n// Betriebsarten (RS-F1/RS-D2 sind dort)\nfbBA(\n    Start         := Start_eff,\n    NotStop       := GVL.NotStopp,\n    Weiter        := Weiter_eff,\n    Fehler        := GVL.Fehler,\n\tStart_Init \t  := Init_Start,                  \n    Auto_Fertig   := fbAuto.Automatikbetrieb_Fertig,\n    Auto_Stoerung := fbAuto.Stoerung_erkannt,\n\tA2_Requested := A2_angefordert,\n\tAlt_abort := alt_abort,\n\tAlt_found := alt_found,\n\tD3_Requested := D3_angefordert,\n\tInit_reached := Init_erreicht,\n\tCycle_ended := Zyklus_beendet\n);\n\n// F1-Flanke startet die Automatik\nedgeF1(CLK := fbBA.F1);\nfbAuto(Automatikbetrieb_Starten := edgeF1.Q);\n\nfbNot(D1 := fbBA.D1);\nGVL.DiagnoseRequested := fbNot.Diagnose_gefordert;\n\nfbProStoer(ProduktionMitStoerung_Starten := fbBA.D3);\nalt_abort := fbProStoer.Stoerung_erkannt;\n\n\nfbInit(A6 := fbBA.A6, A2 := fbBA.A2);\nInit_erreicht := fbInit.Init_erreicht;\n\n// D2 fordert die Diagnose an\nfbDiag(Diagnose_gefordert := fbBA.D2);\nalt_found := fbDiag.Alt_gefunden;",
    "file": "C:\\Users\\Alexander Verkhov\\OneDrive\\Dokumente\\MPA\\TestProjektTwinCATEvents\\TestProjektTwinCATEvents\\Proj1\\POUs\\MAIN.TcPOU"
  },
  {
    "name": "FB_Methode1Job",
    "pou_type": "",
    "implementation_lang": "ST",
    "declaration": "{attribute 'OPC.UA.DA.JobMethod' := 'M_Methode1'} // Dieser FB wird als OPC-UA-Job \"M_Methode1\" veröffentlicht\nFUNCTION_BLOCK FB_Methode1Job\nVAR\n    running : BOOL := FALSE;\n    counter : DINT := 0;\n    reached : BOOL := FALSE;\n    t20s    : TON;        // 20-s-Timer, läuft zyklisch\n    y       : DINT := 0;  // Ergebnis\nEND_VAR\n// Wichtig: Bei Job-Methoden deklariert man den Funktionsbaustein mit\n//{attribute 'OPC.UA.DA.JobMethod' := 'NameDerUAMethod'}\n//und markiert die drei PLC-METHODs Start, CheckState, Abort jeweils mit TcRpcEnable. \n//CheckState besitzt zwingend das Output bBusy, über das der Server erkennt, ob der Job noch läuft.",
    "implementation": "",
    "file": "C:\\Users\\Alexander Verkhov\\OneDrive\\Dokumente\\MPA\\TestProjektTwinCATEvents\\TestProjektTwinCATEvents\\Proj1\\POUs\\FB_Methode1Job.TcPOU"
  },
  {
    "name": "FB_Notaus_D1",
    "pou_type": "FunctionBlock",
    "implementation_lang": "ST",
    "declaration": "FUNCTION_BLOCK FB_Notaus_D1\nVAR_INPUT\n\tD1 : BOOL;\nEND_VAR\nVAR_OUTPUT\n\tNotaus_Entriegelt : BOOL;\n\tDiagnose_gefordert : BOOL;\nEND_VAR\nVAR\n\tton5s : TON;\nEND_VAR",
    "implementation": "IF D1 THEN\n    OPCUA.TriggerD1 := TRUE;         // interne publizierte Variable (kein AT %I*)\n    ton5s(IN := TRUE, PT := T#5S);\nELSE\n    ton5s(IN := FALSE, PT := T#5S);\nEND_IF;\n\nIF ton5s.Q THEN\n    OPCUA.TriggerD1 := FALSE;\n    Diagnose_gefordert := FALSE;\n    GVL.NotStopp := TRUE;\n    GVL.Fehler := FALSE;\n    GVL.Weiter := TRUE;\nEND_IF;",
    "file": "C:\\Users\\Alexander Verkhov\\OneDrive\\Dokumente\\MPA\\TestProjektTwinCATEvents\\TestProjektTwinCATEvents\\Proj1\\POUs\\FB_Notaus_D1.TcPOU"
  }
]