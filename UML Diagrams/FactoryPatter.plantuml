@startuml FactoryPattern
skinparam packageStyle rectangle
skinparam classAttributeIconSize 0
title CommandForceFactory + MonitoringActionForce (Factory + Strategy + Command)

package "Execution Interfaces" {
  interface ICommandForce {
    +execute(plan: Plan): int
  }

  interface IWinnerFilter {
    +filter(winners: vector<string>, corr: string, process: string): vector<string>
  }
}

package "Concrete Executors" {
  class CommandForce implements ICommandForce {
    - mon_: PLCMonitor&
    - oq_: IOrderQueue*
    + execute(plan: Plan): int
  }

  class MonitoringActionForce implements IWinnerFilter {
    - mon_: PLCMonitor&
    - bus_: EventBus&
    - fetch_: (fmIri)->string
    - makePlan_: (corr,payload)->Plan
    - defTimeoutMs_: unsigned
    + filter(winners, corr, process): vector<string>
  }
}

package "Factory" {
  class CommandForceFactory {
    {static} + create(k: Kind, mon: PLCMonitor, oq: IOrderQueue*): ICommandForce
    {static} + createWinnerFilter(mon: PLCMonitor, bus: EventBus,
                   fetcher, planBuilder, defaultTimeoutMs=30000): IWinnerFilter
  }

  enum Kind {
    UseMonitor
    // weitere Kinds möglich
  }
}

package "Orchestrator" {
  class ReactionManager {
    + onMethod(ev: Event): void
    + createCommandForceForPlanAndAck(plan: Plan, checksOk: bool, processName: string): void
    ..uses factory to obtain executors/filters..
  }
}

package "Runtime & Data" {
  class PLCMonitor
  class EventBus
  struct IOrderQueue
  class Plan {
    + correlationId: string
    + resourceId: string
    + ops: vector<Operation>
  }
  class Operation {
    + type: OpType
    + callObjNodeId: string
    + callMethNodeId: string
    + inputs: UAValueMap
    + expOuts: UAValueMap
    + arg: string
    + timeoutMs: int
  }
  struct UAValueMap
  enum OpType {
    CallMethod
    PulseBool
    // ...
  }
}

' --- Relations ---
ReactionManager ..> CommandForceFactory : uses (static create*)
CommandForceFactory ..> ICommandForce : creates
CommandForceFactory ..> IWinnerFilter : creates

ReactionManager --> ICommandForce : execute(plan)
ReactionManager --> IWinnerFilter : filter(winners,...)

CommandForce --> PLCMonitor : uses (mon_)
CommandForce --> IOrderQueue : 0..1 (oq_)
MonitoringActionForce --> PLCMonitor : uses
MonitoringActionForce --> EventBus : posts Acks

Plan *-- "1..*" Operation : composition
Operation ..> UAValueMap
ReactionManager ..> Plan : builds
ReactionManager ..> EventBus : posts Acks

note top of CommandForceFactory
  Static/Simple Factory:
  kapselt Objektbau in
  statischen Methoden.
end note

note right of IWinnerFilter
  Strategy:
  austauschbare
  Filter-Algorithmen.
end note

note bottom of ICommandForce
  Command-Idee:
  Plan (Request) wird
  an Executor übergeben.
end note
@enduml
