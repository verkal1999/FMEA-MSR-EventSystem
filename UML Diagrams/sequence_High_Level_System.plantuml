@startuml Eventbased ExceptionHandling - Sequence (compact)
skinparam linetype ortho
hide footbox

actor PLC
participant "main()" as App
participant PLCMonitor as PLCMon
participant EventBus as Bus
participant ReactionManager as RM
participant FailureRecorder as FR
participant AckLogger as Ack
participant PythonRuntime as Py
participant CommandForceFactory as CFF
participant MonitoringActionForce as MonF
participant SystemReactionForce as SysF
participant CommandForce as CF
participant KGIngestionForce as KGF

== Init (kurz) ==
App -> Bus: create()
App -> RM: create(mon,bus)\nsubscribe(evD2, Acks,…)
App -> FR: create(bus)\nsubscribe(all/errors)
App -> Ack: create(bus)\nsubscribe(acks)
note right of App
Main loop:
- PLCMon.runIterate()
- Bus.process()
end note

== Auslöser D2 ==
PLC -> PLCMon: TriggerD2 Flanke
PLCMon -> PLCMon: buildInventorySnapshotNow()
note over PLCMon
Struct erzeugt:
D2Snapshot{corr, inv}
end note
PLCMon -> Bus: post evD2(payload=D2Snapshot)

== Verteilung ==
Bus -> FR: onEvent(evD2)\nstore snapshotJson[corr]
Bus -> RM: onEvent(evD2)\nenqueue job(corr, inv)

== Diagnose-Job ==
RM -> Py: getFailureModeParameters(lastSkill)
Py --> RM: rowsJson (potFM+expects)
RM -> RM: compareAgainstCache(inv, expects)\n-> winners

alt winners > 0
  RM -> CFF: createWinnerFilter(...)
  CFF --> RM: MonF
  RM -> MonF: filter(winners, corr, process)
  MonF -> Bus: post evReactionPlanned("MonAct Filter")

  loop je Winner
    MonF -> Py: getMonitoringActionForFM(FM)
    Py --> MonF: payload (IRI + rows)
    MonF -> MonF: buildCallMethodPlan(payload)
    note over MonF
    Struct: Plan{ops: [CallMethod...]}
    end note

    loop pro CallMethod
      MonF -> PLCMon: callMethodTyped(obj, meth, inputs, to)
      PLCMon -> PLC: UA_Client_call(...)
      PLC --> PLCMon: outputs[]
      PLCMon --> MonF: outputs[]

      alt outputs match expOuts
        MonF -> MonF: log MATCH
      else mismatch
        MonF -> Bus: post evProcessFail(corr,"MonAct mismatch")
      end
    end
  end

  MonF -> Bus: post evReactionDone(corr, rc)
  MonF --> RM: keptWinners
else winners == 0
  RM -> RM: no KG winners
end

' ===== SystemReaction oder Fallback =====
alt genau 1 Winner nach MonActions
  RM -> CFF: createSystemReactionFilter(...)
  CFF --> RM: SysF
  RM -> SysF: filter([winner], corr, process)
  SysF -> Bus: post evReactionPlanned("SystemReaction")

  SysF -> Py: getSystemReactionForFM(FM)
  Py --> SysF: payload
  SysF -> SysF: buildCallMethodPlan(payload, appendPulse=true)
  note over SysF
  Struct: Plan{ops: [CallMethod..., PulseBool]}
  end note

  loop pro CallMethod
    SysF -> PLCMon: callMethodTyped(...)
    PLCMon -> PLC: UA_Client_call(...)
    PLC --> PLCMon: outputs[]
    PLCMon --> SysF: outputs[]

    alt outputs match
      SysF -> SysF: log OK
    else mismatch
      SysF -> Bus: post evProcessFail(corr,"SysReact mismatch")
    end
  end

  SysF -> Bus: post evReactionDone(corr, rc)
else 0 oder >1 Winner
  RM -> RM: buildFallbackPulsePlan(corr)
  note over RM
  Struct: Plan{ops:[PulseBool(OPCUA.DiagnoseFinished)]}
  end note
  RM -> CFF: createForOp(PulseBool)
  CFF --> RM: CF
  RM -> CF: execute(plan)
  CF -> PLCMon: writeBool(HI)...delay...writeBool(LO)
  CF --> RM: rc
  RM -> Bus: post evProcessFail(corr,"No unique reaction")
  RM -> Bus: post evReactionDone(corr, rc)
end

== Acks & Recorder ==
Bus -> Ack: onEvent(Planned/Done/Fail)\nlog
Bus -> FR: onEvent(Acks)\ncache corr->FM/MonIRIs/SysIRIs

== KG-Ingestion ==
alt evProcessFail oder evKGTimeout eingetroffen
  FR -> FR: buildParams(corr)
  note over FR
  Struct: KgIngestionParams{corr, snapshotWrapped,\n lastSkill, FM, monReacts, sysReacts, ...}
  end note
  FR -> CFF: createForOp(KGIngestion)
  CFF --> FR: KGF
  FR -> KGF: execute(plan{op=KGIngestion, attach=KgIngestionParams})
  KGF -> Bus: post evIngestionPlanned("OccurredFailure")
  KGF -> Py: ingestOccurredFailure(paramsJson)
  Py --> KGF: rc
  KGF -> Bus: post evIngestionDone(corr, rc)
  Bus -> FR: onEvent(evIngestionDone)\ncleanup corr-state
end

@enduml
