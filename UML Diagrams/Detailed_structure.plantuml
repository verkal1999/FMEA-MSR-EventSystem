@startuml Class Structure
skinparam classAttributeIconSize 0
skinparam linetype ortho
'left to right direction
top to bottom direction
'scale max 1200 width
'scale max 800 height

abstract class ReactiveObserver {
    +priority: int
    {abstract} +onEvent(event: Event): void
    +setEventHandled(event: Event): bool
}
'factory design pattern
class ReactionManager {
    -mut_ : std::mutex
    +priority:int = 4
    +onEvent(event: Event): void
    +createPlan(JSON_Respone:string):Plan
}
struct Plan{
    +correlationId:string  
    +resourceId: string
    +ops: vector<Operation>            
    abortRequired: bool;
    degradeAllowed bool;
}
abstract class CommandForce  {
    {abstract} +execute(Task): void
}

enum EventType{
    evD2
    evD3
    evD1
    evReactionPlanned
    evReactionDone
    evKGResult
    evKGTimeout
}

class KG {}
class EventBus{
    -Callbacks: List[EventType, &Class::onEvent]
    -mut_ : std::mutex
    +post(ev:Event):void
    +subscribe<Event>(obj, &Class::onEvent) : void
    +unsubscribe<Event>(obj, &Class::onEvent) : void
    +start()
    +stop()
}
class AckLogger {}

struct Event{
    +type: EventType
    +payload: Payload
}

interface KGInterface {
    +queryForAction(event: Event): List<Action>
    +parseResponse(str): List<Action>
    +ingestFailure(event: Event): void
}

struct InventoryRow {
    + std::string nodeClass;   
    + std::string nodeId;      
    + std::string dtypeOrSig; 
}

class PLCMonitor {
  +connect(): void
  +disconnect(): void
  +run():void
  +onDataChange(nodeId: string, value: any): void
  -bus: EventBus
  +createSnapshot():vector<InventoryRow>
  +wasTimeout(): bool
  +getGEMMAState():str
  -mut_ : std::mutex
'Mutex bei parallelem Zugriff und aufpassen, dass Tas
}

interface ICommand {
  +execute(plan: Plan) : Result
}

class CommandForce {
  - mon_ : PLCMonitor&
  - oq_  : IOrderQueue*
  + execute(p: Plan): int
}

class FailureRecorder {

}

' === Factory-Seite ===
interface ICommandFactory {
  +create(plan: Plan) : ICommand
}
Interface IWinnerFilter{

}

class CommandForceFactory {
  +create(plan: Plan):ICommand
}
' === Beziehungen ===
CommandForce -up-|> ICommand
CommandForceFactory -up-|> ICommandFactory

' Factory erzeugt Produkt
CommandForceFactory ..> CommandForce : «creates»

' Client nutzt nur Abstraktionen
ReactionManager ..> ICommandFactory
ReactionManager *-- Plan: contains
PLCMonitor --> EventBus : publishes on
PLCMonitor --> InventoryRow : creates
EventBus "1" --> "1...*" ReactiveObserver : notify
ReactiveObserver <|-- ReactionManager 
ReactiveObserver <|-- AckLogger 
ReactiveObserver <|-- FailureRecorder
FailureRecorder --> ICommandFactory
ReactionManager  --> KGInterface : uses
EventBus "1" *-- "1...*" Event : contains
KG ..|> KGInterface : interact
ReactionManager --> PLCMonitor: Knows
CommandForce --> PLCMonitor: Knows
ICommandForce <|.. CommandForce
ICommandForce <|.. KGIngestionForce
IWinnerFilter <|.. MonitoringActionForce
IWinnerFilter <|.. SystemReactionForce

CommandForceFactory ..> CommandForce : creates
CommandForceFactory ..> KGIngestionForce : creates
CommandForceFactory ..> MonitoringActionForce : creates
CommandForceFactory ..> SystemReactionForce : creates

ReactionManager ..> IWinnerFilter : uses
ReactionManager ..> ICommand : uses
FailureRecorder ..> ICommand : uses
ICommandForce ..> PLCMonitor : executes on (receiver)

@enduml